<!DOCTYPE html>
<html>

<head>
  <title>Mass Slider Demo</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
    }

    canvas {
      display: block;
    }
  </style>
</head>

<body>
  <input type="range" id="massSlider1" min="0.1" max="100" step="0.1" value="1" />
  <span id="massValue1">1</span>
  <br>
  <input type="range" id="massSlider2" min="0.1" max="100" step="0.1" value="1" />
  <span id="massValue2">1</span>

  <script src="p2.min.js"></script>
  <script src="p2.renderer.min.js"></script>
  <script>
    document.addEventListener("DOMContentLoaded", function (event) {
      let app = new p2.WebGLRenderer(function () {
        let world = new p2.World({
          gravity: [0, -10]
        });

        this.setWorld(world);

        let planeShape = new p2.Plane();
        let plane = new p2.Body({
          position: [0, 0],
          collisionResponse: false
        });
        plane.addShape(planeShape);
        world.addBody(plane);

        let body, body2;

        let massSlider1 = document.getElementById('massSlider1');
        let massSlider2 = document.getElementById('massSlider2');

        let massValue1 = document.getElementById('massValue1');
        let massValue2 = document.getElementById('massValue2');

        // Update masses on slider change
        massSlider1.addEventListener('input', function () {
          body.mass = parseFloat(massSlider1.value);
          massValue1.textContent = massSlider1.value;
        });

        massSlider2.addEventListener('input', function () {
          body2.mass = parseFloat(massSlider2.value);
          massValue2.textContent = massSlider2.value;
        });

        body = new p2.Body({
          mass: parseFloat(massSlider1.value),
          position: [0, 2],
          angularVelocity: 0.5
        });

        body2 = new p2.Body({
          mass: parseFloat(massSlider2.value),
          position: [-3, 2],
          angularVelocity: 1
        });
        console.log(body);
        body.addShape(new p2.Circle({ radius: 0.5 }), [0.5, 0], 0);
        body.addShape(new p2.Circle({ radius: 0.5 }), [-0.5, 0], 0);
        world.addBody(body);

        body2.addShape(new p2.Box({ width: 0.5, height: 2 }), [1, 0], 0);
        body2.addShape(new p2.Box({ width: 0.5, height: 2 }), [0.5, 0], 0);
        body2.addShape(new p2.Box({ width: 0.5, height: 2 }), [-0.5, 0], 0);
        body2.addShape(new p2.Box({ width: 0.5, height: 2 }), [-1, 0], 0);
        world.addBody(body2);






        // Add forces every step
        world.on('postStep', function () {
          applyAABBBuoyancyForces(body, plane.position, k, c);
          applyAABBBuoyancyForces(body2, plane.position, k, c);
        });

        let shapePosition = [0, 0];
        let centerOfBouyancy = [0, 0];
        let liftForce = [0, 0];
        let viscousForce = [0, 0];
        let shapeAngle = 0;
        let k = 100; // up force per submerged "volume"
        let c = 0.8; // viscosity
        let v = [0, 0];
        let aabb = new p2.AABB();

        function applyAABBBuoyancyForces(body, planePosition, k, c) {
          for (let i = 0; i < body.shapes.length; i++) {
            let shape = body.shapes[i];

            // Get shape world transform
            body.vectorToWorldFrame(shapePosition, shape.position);
            p2.vec2.add(shapePosition, shapePosition, body.position);
            shapeAngle = shape.angle + body.angle;

            // Get shape AABB
            shape.computeAABB(aabb, shapePosition, shapeAngle);

            let areaUnderWater;
            if (aabb.upperBound[1] < planePosition[1]) {
              // Fully submerged
              p2.vec2.copy(centerOfBouyancy, shapePosition);
              areaUnderWater = shape.area;
            } else if (aabb.lowerBound[1] < planePosition[1]) {
              // Partially submerged
              let width = aabb.upperBound[0] - aabb.lowerBound[0];
              let height = 0 - aabb.lowerBound[1];
              areaUnderWater = width * height;
              p2.vec2.set(centerOfBouyancy, aabb.lowerBound[0] + width / 2, aabb.lowerBound[1] + height / 2);
            } else {
              continue;
            }

            // Compute lift force
            p2.vec2.subtract(liftForce, planePosition, centerOfBouyancy);
            p2.vec2.scale(liftForce, liftForce, areaUnderWater * k);
            liftForce[0] = 0;

            // Make center of buoyancy relative to the body
            p2.vec2.subtract(centerOfBouyancy, centerOfBouyancy, body.position);

            // Viscous force
            body.getVelocityAtPoint(v, centerOfBouyancy);
            p2.vec2.scale(viscousForce, v, -c);

            // Apply forces
            body.applyForce(viscousForce, centerOfBouyancy);
            body.applyForce(liftForce, centerOfBouyancy);
          }
        }
      });
    });
  </script>
</body>

</html>
